

#define F_CPU 1000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

//unsigned char schet = 0; // Переменная хранит номер ячейки массива digits
unsigned int gr1_1 = 0, gr1_10 = 0;  // Переменные содержат числа для вывода на первую группу индикаторов.
unsigned int gr2_1 = 0, gr2_10 = 0;  // Переменные содержат числа для вывода на вторую группу индикаторов.
unsigned int gr3_1 = 0, gr3_10 = 0;  // Переменные содержат числа для вывода на третью группу индикаторов.
unsigned char a = 1, z = 0; // Переменная содержит номер индикатора в первой группе индикаторов.
// unsigned char ucNumber_1 = 0, ucNumber_2 = 0;
unsigned char viborGruppi = 0; // Переменная настройки
unsigned char inv_1=0, inv_2=0; //Переменные для маргания индикаторами во время настройки.
unsigned char ucDelayBatton_2 = 0; // Переменная отвечает за задержку при нажатии кнопки настройки (кнопка 2)
unsigned char ucChuslo_1 = 0; // Переменная содержит первое число, хранится в памяти. 
unsigned char ucChuslo_2 = 0; // Переменная содержит второе число, хранится в памяти.
unsigned char ucChuslo_3 = 0; // Переменная содержит третье число, хранится в памяти.
unsigned char ucStartTimer = 0; // когда данная переменная станет равна 4 начнеца отсчет обратного времени
unsigned char ucDelayTimer = 0; // переменная хранит минутные задержки времени обратного отсчета
unsigned char ucDelaySeconds = 0; // переменная хранит сикундные интервалы времени

 /************ Масив содержит числа для вывода на семисигментный индикатор.**************/
unsigned int digits [10] = {  
	0b11000000, //0  0b00111111
	0b11111001, //1  0b00000110
	0b10100100, //2  0b01011011
	0b10110000, //3  0b01001111
	0b10011001, //4  0b01100110
	0b10010010, //5  0b01101101
	0b10000010, //6  0b01111101
	0b11111000, //7  0b00000111
	0b10000000, //8  0b01111111
	0b10010000  //9  0b01101111
};



/********* Вектор прерывания таймера счетчика 0 по переполнению **********/
ISR(TIMER0_OVF_vect)
{

/********************************************************************************************************************************/
/********************************************************************************************************************************/

		if (a==1) // Если переменная a равна 2 выводим цифру на второй сигмент первой группы индикатора
		{
			PORTB &= ~((1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2)|(1<<PB1));
			
			if (viborGruppi == 1)  // Если переменная viborGruppi равна одному тогда первая группа сигментов начинает моргать ожедаю настройки.
			{
				if (inv_1 == 1)
				{
					PORTB |= (1<<PB0);
				}
				if (inv_1 == 0)
				{
					PORTB &= ~(1<<PB0);
				}
			}
			
			
			if (viborGruppi != 1)  // Если переменная viborGruppi не равна одному, первая группа сигменнтов просто светится не моргает.
			{
				PORTB |= (1<<PB0);
			}
			
			PORTD = digits [gr1_10]; // Десятки
			
		}
		
/********************************************************************************************************************************/
	
		else if (a==2) // Если переменная a равна 1 выводим цифру на первый сигмент первой группы индикатора
		{
			PORTB &= ~((1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2)|(1<<PB0)); // Гисим ненужные разряды индикаторов
			
			if (viborGruppi == 1) // Если переменная viborGruppi равна одному тогда первая пара сигментов начинает моргать в ожедании настройки.
			{
				if (inv_1 == 1)
				{
					PORTB |= (1<<PB1);
				}
				
				if (inv_1 == 0)
				{
					PORTB &= ~(1<<PB1);
				}
			} 
			   
			if (viborGruppi != 1) // Если переменная viborGruppi не равна одному, первая пара сигменнтов просто светится не моргает.
			{
				PORTB |= (1<<PB1);
			}
			
			
			PORTD = digits [gr1_1]; // Единицы
			
		}
		
/********************************************************************************************************************************/
/********************************************************************************************************************************/
		
		
		else if (a==3) // Если переменная a равна 4 выводим цифру на второй сигмент второй группы индикатора
		{
			PORTB &= ~((1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB1)|(1<<PB0));
			
			if (viborGruppi == 2) // Если переменная viborGruppi равна двум тогда вторая пара сигментов начинает моргать в ожедании настройки.
			{
				if (inv_1 == 1)
				{
					PORTB |= (1<<PB2);
				}
				
				if (inv_1 == 0)
				{
					PORTB &= ~(1<<PB2);
				}
			}
			
			if (viborGruppi != 2) // Если переменная viborGruppi не равна двум, вторая пара сигменнтов просто светится не моргает.
			{
				PORTB |= (1<<PB2);
			}
			
			PORTD = digits [gr2_10]; // Десятки
		}
		
/********************************************************************************************************************************/
		
		else if (a==4) // Если переменная a равна 4 выводим цифру на первый сигмент третьей группы индикатора
		{
			PORTB &= ~((1<<PB5)|(1<<PB4)|(1<<PB2)|(1<<PB1)|(1<<PB0));
			
			if (viborGruppi == 2) // Если переменная viborGruppi равна двум тогда вторая пара сигментов начинает моргать в ожедании настройки.
			{
				if (inv_1 == 1)
				{
					PORTB |= (1<<PB3);
				}
				
				if (inv_1 == 0)
				{
					PORTB &= ~(1<<PB3);
				}
			}
			
			if (viborGruppi != 2) // Если переменная viborGruppi не равна двум, вторая пара сигменнтов просто светится не моргает.
			{
				PORTB |= (1<<PB3);
			}
			PORTD = digits [gr2_1]; // Единицы
		}
		
/********************************************************************************************************************************/
/********************************************************************************************************************************/		
		
		else if (a==5) // Если переменная a равна 5 выводим цифру на второй сигмент третьей группы индикатора
		{
			PORTB &= ~((1<<PB5)|(1<<PB3)|(1<<PB2)|(1<<PB1)|(1<<PB0));
			
			if (viborGruppi == 3) // Если переменная viborGruppi равна трем тогда третья пара сигментов начинает моргать в ожедании настройки.
			{
				if (inv_1 == 1)
				{
					PORTB |= (1<<PB4);
				}
				
				if (inv_1 == 0)
				{
					PORTB &= ~(1<<PB4);
				}
			}
			
			if (viborGruppi != 3) // Если переменная viborGruppi не равна трем, третья пара сигменнтов просто светится не моргает.
			{
				PORTB |= (1<<PB4);
			}
			
			PORTD = digits [gr3_10]; // Десятки
		}
		
/********************************************************************************************************************************/		
		
		else if (a==6) // Если переменная a равна 6 выводим цифру на первый сигмент третьей группы индикатора
		{
			PORTB &= ~((1<<PB4)|(1<<PB3)|(1<<PB2)|(1<<PB1)|(1<<PB0));
			
			if (viborGruppi == 3) // Если переменная viborGruppi равна трем тогда третья пара сигментов начинает моргать в ожедании настройки.
			{
				if (inv_1 == 1)
				{
					PORTB |= (1<<PB5);
				}
				
				if (inv_1 == 0)
				{
					PORTB &= ~(1<<PB5);
				}
			}
			
			if (viborGruppi != 3) // Если переменная viborGruppi не равна трем, третья пара сигменнтов просто светится не моргает.
			{
				PORTB |= (1<<PB5);
			}
			PORTD = digits [gr3_1]; // Единицы
		}
		
		a++;
		if (a>6) a=1;
	
}

/********* Вектор прерывания таймера счетчика 1 по совпадению **********/

ISR(TIMER1_COMPA_vect)
{
	if (inv_1 == 1)
	{
		inv_1 = 0;
	}
	else if (inv_1 == 0)
	{
		inv_1 = 1;
	}
	
	if (~PINC & (1<<PC1))
	{
		ucDelayBatton_2++;
		
		if (ucDelayBatton_2 > 6)
		{
			ucDelayBatton_2 = 6;
		}
	}
	
	else if (PINC |= (1<<PC1))
	{
		ucDelayBatton_2 = 0;
	}
	
	
	if (ucDelayTimer < 120)
	{
		ucDelayTimer++;
	}
		
	if (ucDelaySeconds < 1) ucDelaySeconds++;
	
}

/********* функция раскладывает число на десятки и единицы **********/

void chislo_1 (unsigned char chislo_a)
{
	
	gr1_10 = chislo_a / 10; // Переменной gr1_10 писваеваем цифру оставшуюся от вычисления chislo_1%100/10, это будут десятки в первой группе индикаторов
	gr1_1  = chislo_a % 10; // Переменной gr1_1 писваеваем цифру оставшуюся от вычисления chislo_1%10, это будут единицы в первой группе индикаторов
	
}

/********* функция раскладывает число на десятки и единицы **********/

void chislo_2 (unsigned char chislo_b)
{
	
	gr2_10 = chislo_b / 10; // Переменной gr2_10 писваеваем цифру оставшуюся от вычисления chislo_1%100/10, это будут десятки во второй группе индикаторов
	gr2_1  = chislo_b % 10; // Переменной gr2_1 писваеваем цифру оставшуюся от вычисления chislo_1%10, это будут единицы во второй группе индикаторов
	
}

/********* функция раскладывает число на десятки и единицы **********/

void chislo_3 (unsigned char chislo_c)
{
	gr3_10 = chislo_c / 10; // Переменной gr3_10 писваеваем цифру оставшуюся от вычисления chislo_1%100/10, это будут десятки в третьей группе индикаторов
	gr3_1  = chislo_c % 10; // Переменной gr3_1 писваеваем цифру оставшуюся от вычисления chislo_1%10, это будут единицы в третьей группе индикаторов
}

/********* функция зуммера **********/
void zoomer_50ms (void)
{
	PORTB |= (1<<PB7);
	_delay_ms(50);
	PORTB &= ~(1<<PB7);
}


void setupMk(); // Насторйки Микроконтроллера

void EEPROM_write(unsigned int uiAddress, unsigned char ucData); //Функция отвечающая за запись в память EEPROM

unsigned char EEPROM_read(unsigned int uiAddress); //Функция отвечает за чтение данных из EEPROM памяти

int main(void)
{
 
  setupMk(); // Функция содержит настройки портов МК.
  
    if ((~PINC & (1<<PC0)) && (~PINC & (1<<PC2))) // При одновременно нажатых кнопках 1 и 3, при старте устройства данные в памяти EEPROM обнуляются
    {
	    EEPROM_write(0x01, 0x00);
	    EEPROM_write(0x02, 0x00);
	    EEPROM_write(0x03, 0x00);
    }
  
 ucChuslo_1 = EEPROM_read(0x01);  // Считываем настройки из памяти EEPROM для первого индикатора
 ucChuslo_2 = EEPROM_read(0x02);  // Считываем настройки из памяти EEPROM для второго индикатора
 ucChuslo_3 = EEPROM_read(0x03);  // Считываем настройки из памяти EEPROM для третьего индикатора
 
 
  

  
    while (1) 
    {
		
		chislo_1(ucChuslo_1); // число которое будет выведено в первой группе индикаторов.
		
		chislo_2(ucChuslo_2); // число которое будет выведено во второй группе индикаторов.
		
		chislo_3(ucChuslo_3); // число которое будет выведено в третьей группе индикаторов.

	

		if (~PINC & (1<<PC1)) // При нажатии кнопки 2 входим в режим настройки таймера.
		{
			
			if (ucDelayBatton_2 == 6)  // при удержании конпки 2, три и более секунды попадаем в режим настройки
			{
				
				viborGruppi = 1; // переменная отвечает за выбор группы индикаторов (пары индикаторов)
				ucStartTimer = 1;
				
			}
			
			else if (viborGruppi == 1)
				{
					
					viborGruppi = 2; // переменная отвечает за выбор группы индикаторов (пары индикаторов)
					ucStartTimer = 2;
					while (~PINC & (1<<PC1))
					;
					_delay_ms(200);
				}
			
				else if (viborGruppi == 2)
					{
						
						viborGruppi = 3; // переменная отвечает за выбор группы индикаторов (пары индикаторов)
						ucStartTimer = 3;
						while (~PINC & (1<<PC1))
						;
						_delay_ms(200);
					}
					
					else if (viborGruppi == 3)
						{
							
							viborGruppi = 4; // переменная отвечает за выбор группы индикаторов (пары индикаторов)
							ucStartTimer = 4;
						}
			
			if (viborGruppi>3)
			{
				viborGruppi = 0;
			}
		}

/******************** Данный участок кода отвечает за настройку первого числа для первой пары индикаторов**********************************/		
	
	if (viborGruppi == 1)  // Если переменная равно 1 зачит мы вошли в настройку первой группы индикаторов (первой пары) и можем увеличивать или уменьшать значение.
	{
	
		if (~PINC & (1<<PC0)) // нажимаю кнопку на пине PC0 мы увиличиваем значение на первой паре индикаторов
		{
			ucChuslo_1++;
			_delay_ms(200);
			
			zoomer_50ms (); // пикаем зуммером при нажатии кнопки
			
			if (ucChuslo_1 >= 60)
			{
				ucChuslo_1 = 60;
			}
			
			EEPROM_write(0x01, ucChuslo_1); //записываем в память EEPROM число настроенное на превом индикаторе
		}
		
		if (~PINC & (1<<PC2)) // нажимаю кнопку на пине PC2 мы уменьшаем значение на первой паре индикаторов
		{

			if (ucChuslo_1 > 0)
			{
				ucChuslo_1--;
				_delay_ms(200);
				
			}
			
			zoomer_50ms (); // пикаем зуммером при нажатии кнопки
			
			if (ucChuslo_1 == 0)
			{
				ucChuslo_1 = 0;
			}
			
			EEPROM_write(0x01, ucChuslo_1); //записываем в память EEPROM число настроенное на превом индикаторе
		}
	
	}
	
/******************** Данный участок кода отвечает за настройку первого числа для первой пары индикаторов**********************************/

if (viborGruppi == 2)  // Если переменная равно 2 зачит мы вошли в настройку второй группы индикаторов (второй пары) и можем увеличивать или уменьшать значение.
{
	
	if (~PINC & (1<<PC0)) // нажимаю кнопку на пине PC0 мы увиличиваем значение на второй паре индикаторов
	{
		ucChuslo_2++;
		_delay_ms(200);
		
		zoomer_50ms (); // пикаем зуммером при нажатии кнопки
		
		if (ucChuslo_2 >= 60)
		{
			ucChuslo_2 = 60;
		}
		
		EEPROM_write(0x02, ucChuslo_2); //записываем в память EEPROM число настроенное на втором индикаторе
	}
	
	if (~PINC & (1<<PC2)) // нажимаю кнопку на пине PC2 мы уменьшаем значение на второй паре индикаторов
	{

		if (ucChuslo_2 > 0)
		{
			ucChuslo_2--;
			_delay_ms(200);
		}
		
		zoomer_50ms (); // пикаем зуммером при нажатии кнопки
		
		if (ucChuslo_2 == 0)
		{
			ucChuslo_2 = 0;
		}
		
		EEPROM_write(0x02, ucChuslo_2); //записываем в память EEPROM число настроенное на втором индикаторе
		
	}
	
}

/******************** Данный участок кода отвечает за настройку первого числа для первой пары индикаторов**********************************/

	if (viborGruppi == 3)  // Если переменная равно 3 зачит мы вошли в настройку третьей группы индикаторов (третьей пары) и можем увеличивать или уменьшать значение.
	{
		
		if (~PINC & (1<<PC0)) // нажимаю кнопку на пине PC0 мы увиличиваем значение на третьей паре индикаторов
		{
			ucChuslo_3++;
			_delay_ms(200);
			
			zoomer_50ms (); // пикаем зуммером при нажатии кнопки
			
			if (ucChuslo_3 >= 60)
			{
				ucChuslo_3 = 60;
			}
			
			EEPROM_write(0x03, ucChuslo_3); //записываем в память EEPROM число настроенное на третьем индикаторе
			
		}
		
		if (~PINC & (1<<PC2)) // нажимаю кнопку на пине PC2 мы уменьшаем значение на третьей паре индикаторов
		{

			if (ucChuslo_3 > 0)
			{
				ucChuslo_3--;
				_delay_ms(200);
			}
			
			zoomer_50ms (); // пикаем зуммером при нажатии кнопки
			
			if (ucChuslo_3 == 0)
			{
				ucChuslo_3 = 0;
			}
			
			EEPROM_write(0x03, ucChuslo_3); //записываем в память EEPROM число настроенное на третьем индикаторе
			
		}
		
	}
	
/******************************************************************************************************************************************/



	if (ucStartTimer == 4)
	{
		if (ucDelaySeconds == 1) PORTB ^= 1<<PB6, ucDelaySeconds = 0; 
		if ((ucChuslo_1 == 0) && (ucChuslo_2 == 0) && (ucChuslo_3 == 0)) PORTB &= ~(1<<PB6), ucDelayTimer = 0;
		
		if (!(ucChuslo_1 == 0)) PORTC |= (1<<PC3);
		if (!(ucChuslo_2 == 0)) PORTC |= (1<<PC4);
		if (!(ucChuslo_3 == 0)) PORTC |= (1<<PC5);
		
		if (ucDelayTimer == 120)
		{
			
			if (!(ucChuslo_1 == 0)) ucChuslo_1--;
			if (!(ucChuslo_2 == 0)) ucChuslo_2--;
			if (!(ucChuslo_3 == 0)) ucChuslo_3--;
			
			ucDelayTimer = 0;
		}
			
			
			
		
		if (ucChuslo_1 == 0) PORTC &= ~(1<<PC3);
		if (ucChuslo_2 == 0) PORTC &= ~(1<<PC4);
		if (ucChuslo_3 == 0) PORTC &= ~(1<<PC5);
		
	
		
	}



/******************************************************************************************************************************************/
	}
	
}




void setupMk()  // Переменная содержит настройки портов МК.
{
	/********* Настраиваем порты ввода вывода**********/
	DDRD |= (1<<PD7)|(1<<PD6)|(1<<PD5)|(1<<PD4)|(1<<PD3)|(1<<PD2)|(1<<PD1)|(1<<PD0); // Настраиваем прот D на выход. Порт D управляет сигментами выводя на них требуемое число.
	PORTD |= (1<<PD5)|(1<<PD4)|(1<<PD3)|(1<<PD2)|(1<<PD1)|(1<<PD0); // Подаем на первые 6ть пинов порт D высокий уровень.
	PORTD &= ~((1<<PD7)|(1<<PD6)); // На 7й и 6й пины порта D подаем низкий уровень.
	
	DDRB |= (1<<PB7)|(1<<PB6)|(1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2)|(1<<PB1)|(1<<PB0); // Настраиваем прот B на выход. Первые 5ть пинов будут управлять группами индикаторов.
	//PORTB |= (1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2)|(1<<PB1)|(1<<PB0); // Подаем высокий уровень на первые 5ть пинов прота B.
	PORTB &= ~((1<<PB7)|(1<<PB6)|(1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2)|(1<<PB1)|(1<<PB0)); // Пины 6й и 7й порта B Настраиваем на низкий уровень.
	//DDRB |= (1<<PB6);
	//PORTB &= ~(1<<PB6);
	//PORTB |= 1<<PB6;
	
	DDRC &= ~((1<<PC2)|(1<<PC1)|(1<<PC0));  // Пины с 1го по 3й порта C настраиваем на вход. На этих пинах будут кнопки.
	DDRC |= (1<<PC3)|(1<<PC4)|(1<<PC5); // Пины с 3го по 5й порта C настраиваем на выход. Данные пины управляют нагрузкой.
	PORTC |= (1<<PC2)|(1<<PC1)|(1<<PC0); // На пины с 1го по 2й порта C подаем высокий уровень. Кнопка будет срабатывать при появлении низкого уровня на пинах.
	PORTC &= ~((1<<PC3)|(1<<PC4)|(1<<PC5)); // На пины с 3го по 5й подаем низкий уровень. Данные пины управляют нагрузкой.
	//PORTC |= (1<<PC3)|(1<<PC4)|(1<<PC5);
	
	/********* Настраиваем таймкрсчетчик 0 **********/
	TCCR0 |= (1<<CS01); // настриваем предделитель таймерасчетчика 0 на 8 тем самым запуская таймер счетчик. Уменьшая частоту в восемьраз 1000000/8=125000f. 1/125000=0.000008мкс.
	TIMSK |= (1<<TOIE0); // Разрешаем прерывание по переполнению таймер счетчика 0.
	TCNT0 = 0; // Сбрасываем содержимое регистра TCNT0 в 0 во избежании попадания в него разного мусора.
	
	/********* Настраиваем таймкрсчетчик 1 **********/
	
	TCCR1B &= ~(1<<CS12); // настраиваем предделитель таймера счетчика 1 на 64 тем самым запуская таймер счетчик. Уменьшая частоту в 64 раза 1000000/64=15625f. 1/15625=0.000064мкс.
	TCCR1B |= (1<<CS11)|(1<<CS10); // настраиваем предделитель таймера счетчика 1 на 64 тем самым запуская таймер счетчик. Уменьшая частоту в 64 раза 1000000/64=15625f. 1/15625=0.000064мкс.
	TCCR1B |= (1<<WGM12); // Настраиваем сброс регистра TCNT1 в ноль при совпадении с регистром OCR1A.
	TIMSK |= (1<<OCIE1A); // Разрешение прерывания пр совпадении таймера счетчика 1.
	//OCR1A = 15625; // Заносим в регистр совпадения число 15625. Теперь когда счет в регистре TCNT1 дойдет до числа 15625 мы получим временной интервал 1 секунда.
	OCR1A = 7812;
	TCNT1 = 0; // Сбрасываем содержимое регистра TCNT1 в 0 во избежании попадания в него разного мусора.
	
	_delay_ms(1000);

		PORTB |= (1<<PB7);
		_delay_ms(250);
		PORTB &= ~(1<<PB7);
	
	
	sei(); // Глобальное разрешение прерываний.
}


void EEPROM_write(unsigned int uiAddress, unsigned char ucData)
{
	
	while(EECR & (1<<EEWE))
	;
	
	EEAR = uiAddress;
	
	EEDR = ucData;
	
	EECR |= (1<<EEMWE);
	
	EECR |= (1<<EEWE);
}


unsigned char EEPROM_read(unsigned int uiAddress)
{
	
	while(EECR & (1<<EEWE))
	;
	
	EEAR = uiAddress;
	
	EECR |= (1<<EERE);
	
	return EEDR;
}